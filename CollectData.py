import csv
from collections import defaultdict
import numpy as np
from math import cos, asin, sqrt, pi
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans


# Read the CSV file and extract important information into a dictionary
def read_csv(csv_file_path='./data/final_data_for_modeling.csv'):
    # Dictionary to store coordinates for each unique field_fvid (lat, lng, count)
    field_data = defaultdict(list)

    # Read the CSV file and extract important information into field_data
    try:
        with open(csv_file_path, mode='r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            count = 0
            for row in reader:
                #if count > 200:
                #    break
                count += 1
                field_fvid = row['field_fvid']
                lat = float(row['lat'])
                lng = float(row['lng'])
                
                # Calculate averages for cpba_count and cpbl_count
                cpba_count = float(row['cpba_count'])
                cpbl_count = float(row['cpbl_count'])
                avg_count = (cpba_count + cpbl_count) / 2
                
                # Add to field_coordinates
                field_data[field_fvid] = (lat, lng, avg_count)
                
    except FileNotFoundError:
        print(f"Error: File not found at {csv_file_path}")
    except KeyError as e:
        print(f"Error: Missing expected column in CSV file: {e}")
    except ValueError as e:
        print(f"Error: Invalid data format in CSV file: {e}")
        
    return field_data




# Calculate distances between field coordinates and save to a distance matrix
def create_distance_matrix(field_data, cutoff=10000):
    # Calculate distances between field coordinates and save to a distance matrix

    # Function to calculate distance between two coordinates in km using Haversine formula
    def distance(lat1, lon1, lat2, lon2):
        r = 6371 # km
        p = pi / 180

        a = 0.5 - cos((lat2-lat1)*p)/2 + cos(lat1*p) * cos(lat2*p) * (1-cos((lon2-lon1)*p))/2
        return 2 * r * asin(sqrt(a))

    grid = np.eye(len(field_data)+1, dtype=int)
    fvids = list(field_data.keys())
    for i in range(len(field_data)):
        grid[i+1][0] = fvids[i]
        grid[0][i+1] = fvids[i]

    for i in range(len(field_data)):
        for j in range(i, len(field_data)):
            lat1 = field_data[fvids[i]][0]
            lon1 = field_data[fvids[i]][1]
            lat2 = field_data[fvids[j]][0]
            lon2 = field_data[fvids[j]][1]
        
            dist = int(1000* distance(lat1, lon1, lat2, lon2)) # Convert km to meters for more precision
            if (dist <= cutoff): # Only store distances less than or equal to cutoff
                grid[i+1][j+1] = dist

    np.savetxt('./data/distances.csv', grid, delimiter = ",", fmt='%i')



# Plotting the coordinates using matplotlib to visualize the field locations
def plot_coordinates(field_data, output_path='./out/field_locations.png'):
    # Prepare data for plotting
    plot_data = {'Latitude': [], 'Longitude': [], 'Cluster': []}
    for _, (lat, lng, _, *rest) in field_data.items():
        plot_data['Latitude'].append(lat)
        plot_data['Longitude'].append(lng)
        # Use the fourth field (cluster) if it exists, otherwise default to None
        plot_data['Cluster'].append(rest[0] if len(rest) > 0 else None)

    # Convert to a format suitable for plotting
    df = pd.DataFrame(plot_data)

    # If 'Cluster' column has valid data, use it for coloring
    if df['Cluster'].notnull().all():
        plt.scatter(x=df['Longitude'], y=df['Latitude'], c=df['Cluster'], cmap='viridis', s=50)
    else:
        plt.scatter(x=df['Longitude'], y=df['Latitude'], color='blue', s=50)

    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.title('Field Locations')
    #plt.colorbar(label='Cluster') if df['Cluster'].notnull().all() else None

    # Save the plot to a PNG file
    plt.savefig(output_path, format='png')
    plt.close()
    
#Add a feature to this method that gives the points on the plot color based on the fourth field of the field data generated by the KMeans algorithm. If the fourth field is not there, leave the color as default.    

    
    
def cluster_coordinates(field_data, n_clusters=5, iters=2000, random_state=42):
    # Prepare data for clustering
    coordinates = np.array([[lat, lng] for lat, lng, _ in field_data.values()])
    
    # Perform KMeans clustering
    kmeans = KMeans(n_clusters=n_clusters, max_iter=iters, random_state=random_state)
    kmeans.fit(coordinates)
    
    # Add cluster labels to the field data
    for i, fvid in enumerate(field_data.keys()):
        field_data[fvid] = (*field_data[fvid], kmeans.labels_[i])
    
    return field_data
    




# Query the user for their preferences
create_distance_matrix_in = input("Calculate the distance matrix? (y/n): ").strip().lower() == 'y'
plot_coordinates_in = input("Plot the coordinates? (y/n): ").strip().lower() == 'y'
clustered_in = False
if (plot_coordinates_in):
    clustered_in = input("Cluster the coordinates before plotting? (y/n): ").strip().lower() == 'y'

CUTOFF = 10000  # Cutoff distance in meters for the distance matrix
plot_coordinates_path_unclustered = './out/field_locations.png'
plot_coordinates_path_clustered = './out/field_locations_clustered.png'
CLUSTERS = 50   # Number of clusters for KMeans


# Read the CSV file and extract important information into field_data
field_data = read_csv('./data/final_data_for_modeling.csv')
print("Read data from CSV file successfully.")

# Perform actions based on user preferences
if (create_distance_matrix_in):
    create_distance_matrix(field_data, cutoff=CUTOFF)
    print("Distance matrix saved to './data/distances.csv'.")

if (plot_coordinates_in):
    if clustered_in:
        cluster_coordinates(field_data, n_clusters=50)
        print("Coordinates clustered successfully.")
        plot_coordinates(field_data, output_path=plot_coordinates_path_clustered)
        print(f"Plot saved to '{plot_coordinates_path_clustered}'.")
    else:
        plot_coordinates(field_data, output_path=plot_coordinates_path_unclustered)
        print(f"Plot saved to '{plot_coordinates_path_unclustered}'.")



#print("Field data:", field_data)