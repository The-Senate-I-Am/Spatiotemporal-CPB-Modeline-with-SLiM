// set up a simple neutral simulation
initialize()
{

    initializeSLiMOptions(nucleotideBased=T);
    defineConstant("L", initializeAncestralNucleotides("..\\data\\ref.fasta")); 
    initializeMutationTypeNuc("m1", 0.5, "f", 0.0);
    initializeGenomicElementType("g1", m1, 1.0, mmJukesCantor(1e-7));
    initializeGenomicElement(g1, 0, L-1);
    initializeRecombinationRate(1e-8);

    /*
	// set the overall mutation rate
	initializeMutationRate(1e-7);
	// m1 mutation type: neutral
	initializeMutationType("m1", 0.5, "f", 0.0);
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	// uniform chromosome of length 100 kb
	initializeGenomicElement(g1, 0, 99999);
	// uniform recombination along the chromosome
	initializeRecombinationRate(1e-8);
    */
}
// create a population of 500 individuals
1 early()
{
	
    // Read in cluster data from CSV files
    if (!fileExists("..\\data\\cluster_distances.csv")) {
        print("cluster_distances.csv not found");
        sim.simulationFinished();
    }
    distDF = readCSV("..\\data\\cluster_distances.csv", colNames=T, sep=",");
    if (isNULL(distDF)) {
    	print("Could not read cluster_distances.csv");
    	sim.simulationFinished();
    }

    if (!fileExists("..\\data\\cluster_data.csv")) {
        print("cluster_data.csv not found");
        sim.simulationFinished();
    }
    propDF = readCSV("..\\data\\cluster_data.csv", colNames=T, sep=",");
    if (isNULL(propDF)) {
    	print("Could not read cluster_data.csv");
    	sim.simulationFinished();
    }


    distMX = distDF.asMatrix();



    for (i in 0:(propDF.nrow-1)) {
        sim.addSubpop("p"+i, asInteger(propDF.getValue("Average Count")[i] * 100));
    }
    CUTOFF = 15000;
    
    for (i in 0:(ncol(distMX)-1)) {
        count = 0;
        for (j in 0:(nrow(distMX)-1)) {
            if (distMX[i+ncol(distMX)*j] < CUTOFF) {
            	count = count + 1;
            }
        }
        if (count > 0) {
            migrationRate = 0.7 / count; // 0.3 chance of not migrating
            for (j in 0:(ncol(distMX)-1)) {
            	if (i != j & distMX[i+ncol(distMX)*j] < CUTOFF) {
                    sim.subpopulations[i].setMigrationRates(sim.subpopulations[j], migrationRate);
            	}
            }
        }
    }

    //Remove the first line of refFastaString which is the header
    refFastaStrings = readFile("..\\data\\ref.fasta");
    refFastaString = "";
    for (s in refFastaStrings) {
        if (!strprefix(s, ">")) { 
            refFastaString = refFastaString + s;
        }
    }
    
    //sim.subpopulations[0].outputVCFSample(5);

    sim.subpopulations[0].haplosomes.addNewDrawnMutation(m1, 0, sim.subpopulations[0], "T");

    sim.subpopulations[0].haplosomes.addNewDrawnMutation(m1, 3, sim.subpopulations[0], "T");

    sim.subpopulations[0].haplosomes.addNewDrawnMutation(m1, 12, sim.subpopulations[0], "T");

    print("=======================================================================================");
    print("=======================================================================================");

    sim.subpopulations[0].outputVCFSample(5);


    /*for (i in 0:(propDF.nrow-1)) {
        fastaPath = "..\\data\\FASTAs\\" + i + ".fasta";
        if (!fileExists(fastaPath)) {
            print("FASTA file for subpopulation " + i + " not found");
            sim.simulationFinished();
        }

        fastaString = readFile(fastaPath);
        if (isNULL(fastaString)) {
            print("Could not read FASTA file for subpopulation " + i);
            sim.simulationFinished();
        }

        for (j in 0:(length(refFastaString)-1)) {
            if (refFastaString[j] != fastaString[j]) {
                sim.subpopulations[i].haplosomes.addNewDrawnMutation(m1, j, sim.subpopulations[i], fastaString[j]);
            }
        }        
    }*/
}
// run to tick 10000
10000 early()
{
    sim.subpopulations[0].outputVCFSample(5);
	sim.simulationFinished();
}